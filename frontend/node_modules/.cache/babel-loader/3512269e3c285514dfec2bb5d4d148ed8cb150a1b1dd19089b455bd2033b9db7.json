{"ast":null,"code":"import _t from \"@monaco-editor/loader\";\nimport { memo as Te } from \"react\";\nimport ke, { useState as re, useRef as S, useCallback as oe, useEffect as ne } from \"react\";\nimport Se from \"@monaco-editor/loader\";\nimport { memo as ye } from \"react\";\nimport K from \"react\";\nvar le = {\n    wrapper: {\n      display: \"flex\",\n      position: \"relative\",\n      textAlign: \"initial\"\n    },\n    fullWidth: {\n      width: \"100%\"\n    },\n    hide: {\n      display: \"none\"\n    }\n  },\n  v = le;\nimport me from \"react\";\nvar ae = {\n    container: {\n      display: \"flex\",\n      height: \"100%\",\n      width: \"100%\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  },\n  Y = ae;\nfunction Me(_ref) {\n  let {\n    children: e\n  } = _ref;\n  return me.createElement(\"div\", {\n    style: Y.container\n  }, e);\n}\nvar Z = Me;\nvar $ = Z;\nfunction Ee(_ref2) {\n  let {\n    width: e,\n    height: r,\n    isEditorReady: n,\n    loading: t,\n    _ref: a,\n    className: m,\n    wrapperProps: E\n  } = _ref2;\n  return K.createElement(\"section\", {\n    style: {\n      ...v.wrapper,\n      width: e,\n      height: r\n    },\n    ...E\n  }, !n && K.createElement($, null, t), K.createElement(\"div\", {\n    ref: a,\n    style: {\n      ...v.fullWidth,\n      ...(!n && v.hide)\n    },\n    className: m\n  }));\n}\nvar ee = Ee;\nvar H = ye(ee);\nimport { useEffect as xe } from \"react\";\nfunction Ce(e) {\n  xe(e, []);\n}\nvar k = Ce;\nimport { useEffect as ge, useRef as Re } from \"react\";\nfunction he(e, r) {\n  let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n  let t = Re(!0);\n  ge(t.current || !n ? () => {\n    t.current = !1;\n  } : e, r);\n}\nvar l = he;\nfunction D() {}\nfunction h(e, r, n, t) {\n  return De(e, t) || be(e, r, n, t);\n}\nfunction De(e, r) {\n  return e.editor.getModel(te(e, r));\n}\nfunction be(e, r, n, t) {\n  return e.editor.createModel(r, n, t ? te(e, t) : void 0);\n}\nfunction te(e, r) {\n  return e.Uri.parse(r);\n}\nfunction Oe(_ref3) {\n  let {\n    original: e,\n    modified: r,\n    language: n,\n    originalLanguage: t,\n    modifiedLanguage: a,\n    originalModelPath: m,\n    modifiedModelPath: E,\n    keepCurrentOriginalModel: g = !1,\n    keepCurrentModifiedModel: N = !1,\n    theme: x = \"light\",\n    loading: P = \"Loading...\",\n    options: y = {},\n    height: V = \"100%\",\n    width: z = \"100%\",\n    className: F,\n    wrapperProps: j = {},\n    beforeMount: A = D,\n    onMount: q = D\n  } = _ref3;\n  let [M, O] = re(!1),\n    [T, s] = re(!0),\n    u = S(null),\n    c = S(null),\n    w = S(null),\n    d = S(q),\n    o = S(A),\n    b = S(!1);\n  k(() => {\n    let i = Se.init();\n    return i.then(f => (c.current = f) && s(!1)).catch(f => f?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", f)), () => u.current ? I() : i.cancel();\n  }), l(() => {\n    if (u.current && c.current) {\n      let i = u.current.getOriginalEditor(),\n        f = h(c.current, e || \"\", t || n || \"text\", m || \"\");\n      f !== i.getModel() && i.setModel(f);\n    }\n  }, [m], M), l(() => {\n    if (u.current && c.current) {\n      let i = u.current.getModifiedEditor(),\n        f = h(c.current, r || \"\", a || n || \"text\", E || \"\");\n      f !== i.getModel() && i.setModel(f);\n    }\n  }, [E], M), l(() => {\n    let i = u.current.getModifiedEditor();\n    i.getOption(c.current.editor.EditorOption.readOnly) ? i.setValue(r || \"\") : r !== i.getValue() && (i.executeEdits(\"\", [{\n      range: i.getModel().getFullModelRange(),\n      text: r || \"\",\n      forceMoveMarkers: !0\n    }]), i.pushUndoStop());\n  }, [r], M), l(() => {\n    u.current?.getModel()?.original.setValue(e || \"\");\n  }, [e], M), l(() => {\n    let {\n      original: i,\n      modified: f\n    } = u.current.getModel();\n    c.current.editor.setModelLanguage(i, t || n || \"text\"), c.current.editor.setModelLanguage(f, a || n || \"text\");\n  }, [n, t, a], M), l(() => {\n    c.current?.editor.setTheme(x);\n  }, [x], M), l(() => {\n    u.current?.updateOptions(y);\n  }, [y], M);\n  let L = oe(() => {\n      if (!c.current) return;\n      o.current(c.current);\n      let i = h(c.current, e || \"\", t || n || \"text\", m || \"\"),\n        f = h(c.current, r || \"\", a || n || \"text\", E || \"\");\n      u.current?.setModel({\n        original: i,\n        modified: f\n      });\n    }, [n, r, a, e, t, m, E]),\n    U = oe(() => {\n      !b.current && w.current && (u.current = c.current.editor.createDiffEditor(w.current, {\n        automaticLayout: !0,\n        ...y\n      }), L(), c.current?.editor.setTheme(x), O(!0), b.current = !0);\n    }, [y, x, L]);\n  ne(() => {\n    M && d.current(u.current, c.current);\n  }, [M]), ne(() => {\n    !T && !M && U();\n  }, [T, M, U]);\n  function I() {\n    let i = u.current?.getModel();\n    g || i?.original?.dispose(), N || i?.modified?.dispose(), u.current?.dispose();\n  }\n  return ke.createElement(H, {\n    width: z,\n    height: V,\n    isEditorReady: M,\n    loading: P,\n    _ref: w,\n    className: F,\n    wrapperProps: j\n  });\n}\nvar ie = Oe;\nvar we = Te(ie);\nimport { useState as Ie } from \"react\";\nimport ce from \"@monaco-editor/loader\";\nfunction Pe() {\n  let [e, r] = Ie(ce.__getMonacoInstance());\n  return k(() => {\n    let n;\n    return e || (n = ce.init(), n.then(t => {\n      r(t);\n    })), () => n?.cancel();\n  }), e;\n}\nvar Le = Pe;\nimport { memo as ze } from \"react\";\nimport We, { useState as ue, useEffect as W, useRef as C, useCallback as _e } from \"react\";\nimport Ne from \"@monaco-editor/loader\";\nimport { useEffect as Ue, useRef as ve } from \"react\";\nfunction He(e) {\n  let r = ve();\n  return Ue(() => {\n    r.current = e;\n  }, [e]), r.current;\n}\nvar se = He;\nvar _ = new Map();\nfunction Ve(_ref4) {\n  let {\n    defaultValue: e,\n    defaultLanguage: r,\n    defaultPath: n,\n    value: t,\n    language: a,\n    path: m,\n    theme: E = \"light\",\n    line: g,\n    loading: N = \"Loading...\",\n    options: x = {},\n    overrideServices: P = {},\n    saveViewState: y = !0,\n    keepCurrentModel: V = !1,\n    width: z = \"100%\",\n    height: F = \"100%\",\n    className: j,\n    wrapperProps: A = {},\n    beforeMount: q = D,\n    onMount: M = D,\n    onChange: O,\n    onValidate: T = D\n  } = _ref4;\n  let [s, u] = ue(!1),\n    [c, w] = ue(!0),\n    d = C(null),\n    o = C(null),\n    b = C(null),\n    L = C(M),\n    U = C(q),\n    I = C(),\n    i = C(t),\n    f = se(m),\n    Q = C(!1),\n    B = C(!1);\n  k(() => {\n    let p = Ne.init();\n    return p.then(R => (d.current = R) && w(!1)).catch(R => R?.type !== \"cancelation\" && console.error(\"Monaco initialization: error:\", R)), () => o.current ? pe() : p.cancel();\n  }), l(() => {\n    let p = h(d.current, e || t || \"\", r || a || \"\", m || n || \"\");\n    p !== o.current?.getModel() && (y && _.set(f, o.current?.saveViewState()), o.current?.setModel(p), y && o.current?.restoreViewState(_.get(m)));\n  }, [m], s), l(() => {\n    o.current?.updateOptions(x);\n  }, [x], s), l(() => {\n    !o.current || t === void 0 || (o.current.getOption(d.current.editor.EditorOption.readOnly) ? o.current.setValue(t) : t !== o.current.getValue() && (B.current = !0, o.current.executeEdits(\"\", [{\n      range: o.current.getModel().getFullModelRange(),\n      text: t,\n      forceMoveMarkers: !0\n    }]), o.current.pushUndoStop(), B.current = !1));\n  }, [t], s), l(() => {\n    let p = o.current?.getModel();\n    p && a && d.current?.editor.setModelLanguage(p, a);\n  }, [a], s), l(() => {\n    g !== void 0 && o.current?.revealLine(g);\n  }, [g], s), l(() => {\n    d.current?.editor.setTheme(E);\n  }, [E], s);\n  let X = _e(() => {\n    if (!(!b.current || !d.current) && !Q.current) {\n      U.current(d.current);\n      let p = m || n,\n        R = h(d.current, t || e || \"\", r || a || \"\", p || \"\");\n      o.current = d.current?.editor.create(b.current, {\n        model: R,\n        automaticLayout: !0,\n        ...x\n      }, P), y && o.current.restoreViewState(_.get(p)), d.current.editor.setTheme(E), g !== void 0 && o.current.revealLine(g), u(!0), Q.current = !0;\n    }\n  }, [e, r, n, t, a, m, x, P, y, E, g]);\n  W(() => {\n    s && L.current(o.current, d.current);\n  }, [s]), W(() => {\n    !c && !s && X();\n  }, [c, s, X]), i.current = t, W(() => {\n    s && O && (I.current?.dispose(), I.current = o.current?.onDidChangeModelContent(p => {\n      B.current || O(o.current.getValue(), p);\n    }));\n  }, [s, O]), W(() => {\n    if (s) {\n      let p = d.current.editor.onDidChangeMarkers(R => {\n        let G = o.current.getModel()?.uri;\n        if (G && R.find(J => J.path === G.path)) {\n          let J = d.current.editor.getModelMarkers({\n            resource: G\n          });\n          T?.(J);\n        }\n      });\n      return () => {\n        p?.dispose();\n      };\n    }\n    return () => {};\n  }, [s, T]);\n  function pe() {\n    I.current?.dispose(), V ? y && _.set(m, o.current.saveViewState()) : o.current.getModel()?.dispose(), o.current.dispose();\n  }\n  return We.createElement(H, {\n    width: z,\n    height: F,\n    isEditorReady: s,\n    loading: N,\n    _ref: b,\n    className: j,\n    wrapperProps: A\n  });\n}\nvar fe = Ve;\nvar de = ze(fe);\nvar Ft = de;\nexport { we as DiffEditor, de as Editor, Ft as default, _t as loader, Le as useMonaco };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}